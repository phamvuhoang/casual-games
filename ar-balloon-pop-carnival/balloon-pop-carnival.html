<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Balloon Pop Carnival</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; user-select: none; }
        
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        /* Video is mirrored via CSS to feel natural */
        #webcam { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1); z-index: 1; 
        }
        
        #canvas-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 2; pointer-events: none; 
        }
        
        /* UI */
        .ui-layer { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { padding: 20px; display: flex; justify-content: space-between; color: #fff; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        
        #meter-container { 
            width: 300px; height: 30px; background: rgba(0,0,0,0.6); 
            border: 3px solid gold; border-radius: 20px; 
            margin-bottom: 30px; position: relative; overflow: hidden; 
            align-self: center;
        }
        #meter-fill { height: 100%; width: 0%; background: #ff00ff; transition: width 0.1s; }
        
        /* Screens */
        .screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); z-index: 20; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            color: white; pointer-events: auto; text-align: center; 
        }
        .hidden { display: none !important; }
        
        button { 
            background: #e91e63; color: white; border: none; padding: 15px 40px; 
            font-size: 20px; border-radius: 50px; cursor: pointer; margin-top: 20px; font-weight: bold;
        }
        button:hover { transform: scale(1.05); background: #ff4081; }

        .feedback { 
            position: absolute; font-weight: bold; font-size: 30px; 
            text-shadow: 2px 2px 0 #000; pointer-events: none; 
            animation: floatUp 0.8s forwards; 
        }
        @keyframes floatUp { to { transform: translateY(-100px); opacity: 0; } }
    </style>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

<div id="game-container">
    <video id="webcam" playsinline></video>
    <canvas id="canvas-layer"></canvas>
    
    <div id="ui-game" class="ui-layer hidden">
        <div class="hud-top">
            <div id="score">Score: 0</div>
            <div id="time">Time: 60</div>
            <div id="combo">Combo: x0</div>
        </div>
        <div id="meter-container">
            <div id="meter-fill"></div>
        </div>
    </div>

    <div id="screen-loading" class="screen">
        <h1>Loading Carnival...</h1>
        <p>Please allow camera access.</p>
    </div>

    <div id="screen-start" class="screen hidden">
        <h1 style="color:#ffeb3b">ðŸŽˆ AR Balloon Pop ðŸŽˆ</h1>
        <p>Index Finger to <b>POKE</b> | Pinch to <b>THROW DART</b></p>
        <button onclick="startGame()">Start Game</button>
    </div>

    <div id="screen-gameover" class="screen hidden">
        <h1>Time's Up!</h1>
        <h2 id="final-score">Score: 0</h2>
        <button onclick="startGame()">Play Again</button>
    </div>
</div>

<script>
// --- CONFIGURATION ---
const Z_PLANE = 0; // Where balloons live
const CAMERA_Z = 15;
const GRAVITY = -15;

// --- STATE ---
let scene, camera, renderer;
let handsModel, videoElement;
let isPlaying = false;
let balloons = [];
let darts = [];
let particles = [];
let score = 0, time = 60, combo = 0, comboTimer = 0;
let megaMeter = 0;
let spawnTimer = 0;
let clock = new THREE.Clock();
let difficulty = 1;

// Hand Tracking Data (Index 0 and 1)
const handData = [
    { active: false, pos: new THREE.Vector3(), lastPos: new THREE.Vector3(), velocity: new THREE.Vector3(), pinched: false },
    { active: false, pos: new THREE.Vector3(), lastPos: new THREE.Vector3(), velocity: new THREE.Vector3(), pinched: false }
];
const handMarkers = [];

// --- INITIALIZATION ---
window.onload = async () => {
    initThreeJS();
    await initMediaPipe();
};

function initThreeJS() {
    const canvas = document.getElementById('canvas-layer');
    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = CAMERA_Z;

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 5);
    scene.add(ambient, dir);

    renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Create Hand Markers
    const geom = new THREE.SphereGeometry(0.4, 16, 16);
    handMarkers[0] = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));
    handMarkers[1] = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 }));
    scene.add(handMarkers[0], handMarkers[1]);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
}

async function initMediaPipe() {
    videoElement = document.getElementById('webcam');
    
    handsModel = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
    handsModel.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    handsModel.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await handsModel.send({image: videoElement});
        },
        width: 640, height: 480
    });
    
    await cameraUtils.start();
    
    // Once camera starts, show menu
    document.getElementById('screen-loading').classList.add('hidden');
    document.getElementById('screen-start').classList.remove('hidden');
}

// --- GAME LOGIC ---
function startGame() {
    score = 0; time = 60; combo = 0; megaMeter = 0;
    balloons.forEach(b => scene.remove(b.mesh));
    balloons = [];
    darts = [];
    isPlaying = true;
    
    document.getElementById('ui-game').classList.remove('hidden');
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    
    // Audio Context unlock
    if(!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(window.audioCtx.state === 'suspended') window.audioCtx.resume();
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    if(isPlaying) {
        updateGame(dt);
        renderer.render(scene, camera);
    }
}

function updateGame(dt) {
    // Timer
    time -= dt;
    if(time <= 0) {
        isPlaying = false;
        document.getElementById('ui-game').classList.add('hidden');
        document.getElementById('screen-gameover').classList.remove('hidden');
        document.getElementById('final-score').innerText = "Score: " + Math.floor(score);
        return;
    }

    // Spawning
    spawnTimer -= dt;
    if(spawnTimer <= 0) {
        spawnBalloon();
        spawnTimer = Math.max(0.4, 1.5 - (score / 5000)); // Faster as score goes up
    }

    // Balloons
    balloons.forEach((b, i) => {
        b.mesh.position.y += b.speed * dt;
        b.mesh.position.x += Math.sin(Date.now() * 0.002 + b.offset) * 0.02;
        if(b.mesh.position.y > 10) { scene.remove(b.mesh); balloons.splice(i, 1); }
    });

    // Darts
    darts.forEach((d, i) => {
        d.mesh.position.add(d.velocity.clone().multiplyScalar(dt));
        d.velocity.y += GRAVITY * dt * 0.5;
        d.mesh.lookAt(d.mesh.position.clone().add(d.velocity));
        
        // Dart Collision
        for (let j = balloons.length - 1; j >= 0; j--) {
            if(d.mesh.position.distanceTo(balloons[j].mesh.position) < 1.5) {
                popBalloon(j, true);
                // Dart continues through!
            }
        }

        if(d.mesh.position.z < -20 || d.mesh.position.y < -10) {
            scene.remove(d.mesh); darts.splice(i, 1);
        }
    });

    // Particles
    particles.forEach((p, i) => {
        p.life -= dt * 2;
        p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
        p.mesh.material.opacity = p.life;
        if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
    });

    // Process Hand Interaction
    handData.forEach(h => {
        if(!h.active) return;
        
        // POKE Check
        for(let i = balloons.length - 1; i >= 0; i--) {
            // Poke Distance: Finger Radius + Balloon Radius
            if(h.pos.distanceTo(balloons[i].mesh.position) < 1.8) {
                popBalloon(i);
            }
        }

        // THROW Check
        // If was pinched last frame, and not pinched now -> RELEASE
        if(h.wasPinched && !h.pinched) {
            // Calculate flick speed
            const speed = h.velocity.length();
            if(speed > 0.2) { // Sensitivity
                throwDart(h.pos, h.velocity);
            }
        }
        h.wasPinched = h.pinched;
    });

    updateUI();
}

function spawnBalloon() {
    const type = Math.random() > 0.8 ? (Math.random() > 0.5 ? 'bonus' : 'hazard') : 'normal';
    const mat = new THREE.MeshPhongMaterial({ 
        color: type === 'normal' ? (Math.random()>0.5 ? 0xff4444 : 0x4444ff) : (type==='bonus'?0xffd700:0x222222),
        shininess: 100 
    });
    
    const mesh = new THREE.Group();
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), mat);
    sphere.scale.y = 1.2;
    mesh.add(sphere);
    
    // Spawn at bottom, random X within view (-8 to 8 approx)
    mesh.position.set((Math.random()-0.5)*14, -9, Z_PLANE);
    scene.add(mesh);
    
    balloons.push({ 
        mesh, type, 
        speed: 2 + Math.random() * 2, 
        offset: Math.random() * 100 
    });
}

function popBalloon(index, isDart = false) {
    const b = balloons[index];
    if(!b) return;

    createParticles(b.mesh.position, b.mesh.children[0].material.color);
    playSound(b.type === 'hazard' ? 'bad' : 'pop');

    if(b.type === 'hazard') {
        score -= 50;
        combo = 0;
        showText("HAZARD!", b.mesh.position, 'red');
    } else {
        combo++;
        const pts = (b.type === 'bonus' ? 50 : 10) * combo;
        score += pts;
        showText(`+${pts}`, b.mesh.position, 'white');
        megaMeter = Math.min(100, megaMeter + 10);
    }

    scene.remove(b.mesh);
    balloons.splice(index, 1);
}

function throwDart(pos, vel) {
    const dMesh = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5), new THREE.MeshBasicMaterial({color: 0xffff00}));
    dMesh.position.copy(pos);
    dMesh.rotation.x = Math.PI / 2;
    scene.add(dMesh);
    
    // Amplify velocity for fun
    const throwVel = vel.clone().multiplyScalar(20); 
    throwVel.z = -10; // Make it fly into the screen slightly
    darts.push({ mesh: dMesh, velocity: throwVel });
    playSound('throw');
}

// --- HAND TRACKING CORE ---
function onHandsResults(results) {
    // Reset Hand Active State
    handData[0].active = false;
    handData[1].active = false;
    
    handMarkers[0].visible = false;
    handMarkers[1].visible = false;

    if (!results.multiHandLandmarks) return;

    for (let i = 0; i < results.multiHandLandmarks.length; i++) {
        if(i > 1) break;

        const lm = results.multiHandLandmarks[i];
        const h = handData[i];
        h.active = true;

        // Map Coordinates:
        // Video is mirrored via CSS (scaleX(-1)). 
        // MediaPipe x=0(Left) corresponds to Screen Left visually because of mirror.
        // We need to invert logic carefully. 
        // Standard unproject works on NDC (-1 to 1).
        // x: (lm.x - 0.5) * 2  -> This goes -1 (Left) to 1 (Right).
        // Because CSS flips the video, we actually want the 3D object to match the "visual" hand.
        // If I move hand to visual right, MP sees x=0 (raw left). 
        // So we need to map raw x=0 -> NDC x=1. 
        // Formula: (0.5 - lm.x) * 2 * aspect correction
        
        const ndcX = (0.5 - lm[8].x) * 2; // Invert X for mirror effect
        const ndcY = (0.5 - lm[8].y) * 2; // Invert Y for ThreeJS (Up is positive)
        
        // Unproject to Z Plane
        const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
        vector.unproject(camera);
        vector.sub(camera.position).normalize();
        const distance = (Z_PLANE - camera.position.z) / vector.z;
        const worldPos = camera.position.clone().add(vector.multiplyScalar(distance));
        
        // Calculate Velocity
        h.velocity.subVectors(worldPos, h.lastPos).multiplyScalar(0.8); // Smooth slightly
        h.lastPos.copy(h.pos);
        h.pos.copy(worldPos);

        // Pinch Detection (Index tip 8 vs Thumb tip 4)
        // We use screen distance for robustness
        const dx = lm[8].x - lm[4].x;
        const dy = lm[8].y - lm[4].y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        h.pinched = dist < 0.05; // 5% of screen width

        // Update Marker
        handMarkers[i].visible = true;
        handMarkers[i].position.copy(worldPos);
        handMarkers[i].material.color.setHex(h.pinched ? 0x00ff00 : (i===0?0x00ffff:0xffaa00));
        handMarkers[i].scale.setScalar(h.pinched ? 0.8 : 1);
    }
}

// --- UTILS ---
function createParticles(pos, color) {
    for(let i=0; i<8; i++) {
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.3,0.3), new THREE.MeshBasicMaterial({color, side:2, transparent:true}));
        mesh.position.copy(pos);
        mesh.rotation.z = Math.random()*Math.PI;
        scene.add(mesh);
        particles.push({ 
            mesh, life: 1.0, 
            vel: new THREE.Vector3((Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5) 
        });
    }
}

function showText(msg, pos, color) {
    const div = document.createElement('div');
    div.innerText = msg;
    div.className = 'feedback';
    div.style.color = color;
    
    const vec = pos.clone().project(camera);
    const x = (vec.x * .5 + .5) * window.innerWidth;
    const y = (-(vec.y * .5) + .5) * window.innerHeight;
    
    div.style.left = x + 'px'; div.style.top = y + 'px';
    document.body.appendChild(div);
    setTimeout(() => div.remove(), 800);
}

function updateUI() {
    document.getElementById('score').innerText = "Score: " + Math.floor(score);
    document.getElementById('time').innerText = "Time: " + Math.floor(time);
    document.getElementById('combo').innerText = "Combo: x" + combo;
    document.getElementById('meter-fill').style.width = megaMeter + "%";
}

function playSound(type) {
    if(!window.audioCtx) return;
    const osc = window.audioCtx.createOscillator();
    const g = window.audioCtx.createGain();
    osc.connect(g); g.connect(window.audioCtx.destination);
    
    if(type==='pop') {
        osc.frequency.setValueAtTime(300, window.audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, window.audioCtx.currentTime+0.1);
        g.gain.setValueAtTime(0.5, window.audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0, window.audioCtx.currentTime+0.1);
        osc.start(); osc.stop(window.audioCtx.currentTime+0.1);
    } else if (type === 'throw') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(600, window.audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, window.audioCtx.currentTime+0.2);
        g.gain.setValueAtTime(0.3, window.audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0, window.audioCtx.currentTime+0.2);
        osc.start(); osc.stop(window.audioCtx.currentTime+0.2);
    } else { // Bad
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, window.audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, window.audioCtx.currentTime+0.3);
        g.gain.setValueAtTime(0.5, window.audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0, window.audioCtx.currentTime+0.3);
        osc.start(); osc.stop(window.audioCtx.currentTime+0.3);
    }
}
</script>
</body>
</html>