<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Rhythm Master</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #webcam { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #canvas-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; color: white; text-shadow: 2px 2px 4px #000; }
        .screen { display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.7); position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .hidden { display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <div id="game-container">
        <video id="webcam" playsinline></video>
        <canvas id="canvas-layer"></canvas>
        <div id="ui-game" class="ui-layer hidden">
            <div id="score">Score: 0</div>
            <div id="combo">Combo: 0</div>
        </div>
        <div id="screen-start" class="screen">
            <h1>AR Rhythm Master</h1>
            <button id="start-button">Start Game</button>
        </div>
        <div id="screen-gameover" class="screen hidden">
            <h1>Game Over</h1>
            <div id="final-score">Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <audio id="music" src="https://cdn.glitch.com/c163845a-1563-4944-8c8a-e054817a5412%2Fsynth-song-short.mp3?v=1627063118742" crossorigin="anonymous" loop></audio>

    <script>
        // --- Core Three.js Components ---
        let scene, camera, renderer;
        let clock = new THREE.Clock();

        // --- Game Objects & Config ---
        const notes = [];
        const NOTE_SPEED = 10;
        const NOTE_SPAWN_Z = -20;
        const NOTE_DESTROY_Z = 12;
        const HIT_ZONE_Z = 8;
        const TRACKS = [-3, 0, 3]; // X positions for the three note tracks

        // --- Hand Tracking ---
        const handMarkers = [];
        const handData = [
            { visible: false, pos: new THREE.Vector3() },
            { visible: false, pos: new THREE.Vector3() }
        ];

        // --- Game State ---
        let isPlaying = false;
        let score = 0;
        let combo = 0;
        let audio;
        let audioCtx; // For sound effects
        let beatmap; // Will hold the note timings
        let nextNoteIndex = 0;

        // --- Initialization ---
        window.onload = async () => {
            audio = document.getElementById('music');

            // UI Event Listeners
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', startGame);

            initThreeJS();
            await initMediaPipe();
        };

        function initThreeJS() {
            const canvas = document.getElementById('canvas-layer');
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // Handle Window Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Add Hand Markers to the scene
            const markerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const markerMaterial1 = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const markerMaterial2 = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.8 });
            handMarkers[0] = new THREE.Mesh(markerGeometry, markerMaterial1);
            handMarkers[1] = new THREE.Mesh(markerGeometry, markerMaterial2);
            scene.add(handMarkers[0], handMarkers[1]);

            // Start the animation loop
            animate();
        }

        async function initMediaPipe() {
            const videoElement = document.getElementById('webcam');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            hands.onResults(onHandsResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            await camera.start();
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // Update game logic only when playing
            if (isPlaying) {
                // --- Note Spawning ---
                if (nextNoteIndex < beatmap.length && audio.currentTime >= beatmap[nextNoteIndex].time) {
                    spawnNote(beatmap[nextNoteIndex].track);
                    nextNoteIndex++;
                }

                // --- Game Over Check ---
                if (audio.ended || (nextNoteIndex >= beatmap.length && notes.length === 0)) {
                    endGame();
                }

                // --- Note Movement & Destruction ---
                for (let i = notes.length - 1; i >= 0; i--) {
                    const note = notes[i];
                    note.position.z += NOTE_SPEED * dt;

                    // Remove notes that have passed the camera
                    if (note.position.z > NOTE_DESTROY_Z) {
                        scene.remove(note);
                        notes.splice(i, 1);
                        combo = 0; // Break combo on miss
                    }
                }

                // --- Hit Detection ---
                checkHits();

                // --- UI Updates ---
                updateUI();

                // Update Hand Markers
                for (let i = 0; i < 2; i++) {
                    handMarkers[i].visible = handData[i].visible;
                    if (handData[i].visible) {
                        handMarkers[i].position.copy(handData[i].pos);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // --- Hand Tracking Callbacks ---
        function onHandsResults(results) {
            // Hide all hands first
            handData[0].visible = false;
            handData[1].visible = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    if (i >= 2) break; // Max 2 hands

                    const landmarks = results.multiHandLandmarks[i];
                    handData[i].visible = true;

                    // Get the position of the index finger tip (landmark 8)
                    const landmark = landmarks[8];

                    // Convert normalized coordinates to world coordinates
                    const ndcX = (0.5 - landmark.x) * 2; // Invert X for mirror effect
                    const ndcY = (0.5 - landmark.y) * 2; // Invert Y

                    const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
                    vector.unproject(camera);
                    vector.sub(camera.position).normalize();
                    const distance = (HIT_ZONE_Z - camera.position.z) / vector.z;
                    handData[i].pos.copy(camera.position).add(vector.multiplyScalar(distance));
                }
            }
        }

        // --- Game Logic Functions ---
        function checkHits() {
            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i];
                const noteZ = note.position.z;

                // Check if the note is in the hit zone
                if (noteZ > HIT_ZONE_Z - 1 && noteZ < HIT_ZONE_Z + 1) {
                    for (const hand of handData) {
                        if (hand.visible) {
                            const dist = hand.pos.distanceTo(note.position);

                            // If hand is close enough to the note
                            if (dist < 2) {
                                scene.remove(note);
                                notes.splice(i, 1);

                                // --- Scoring ---
                                combo++;
                                score += 10 * combo;
                                playSound('hit');

                                break; // Note is hit, no need to check other hand
                            }
                        }
                    }
                }
            }
        }

        function updateUI() {
            document.getElementById('score').innerText = `Score: ${score}`;
            document.getElementById('combo').innerText = `Combo: ${combo}`;
        }

        function playSound(type) {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            if (type === 'hit') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        function createBeatmap() {
            // A simple beatmap (time in seconds, track index 0-2)
            // Replace with a real song's beatmap later
            const simpleMap = [
                { time: 1.0, track: 0 }, { time: 1.5, track: 1 }, { time: 2.0, track: 2 },
                { time: 2.5, track: 1 }, { time: 3.0, track: 0 }, { time: 3.5, track: 2 },
                { time: 4.0, track: 1 }, { time: 4.5, track: 0 }, { time: 4.5, track: 2 },
                // Add more to extend the song
            ];
            return simpleMap;
        }

        function startGame() {
            // Reset State
            score = 0;
            combo = 0;
            nextNoteIndex = 0;
            notes.forEach(note => scene.remove(note));
            notes.length = 0;

            beatmap = createBeatmap();

            // UI
            document.getElementById('screen-start').classList.add('hidden');
            document.getElementById('screen-gameover').classList.add('hidden');
            document.getElementById('ui-game').classList.remove('hidden');

            // Start Music
            audio.currentTime = 0;
            audio.play();

            isPlaying = true;
        }

        function endGame() {
            isPlaying = false;
            audio.pause();

            // UI
            document.getElementById('ui-game').classList.add('hidden');
            document.getElementById('screen-gameover').classList.remove('hidden');
            document.getElementById('final-score').innerText = `Score: ${score}`;
        }

        function spawnNote(trackIndex) {
            const geometry = new THREE.BoxGeometry(2, 1, 1);
            const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
            const note = new THREE.Mesh(geometry, material);

            note.position.x = TRACKS[trackIndex];
            note.position.y = 0; // Center of the screen vertically
            note.position.z = NOTE_SPAWN_Z;

            notes.push(note);
            scene.add(note);
        }
    </script>
</body>
</html>