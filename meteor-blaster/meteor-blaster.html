<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Meteor Blaster</title>
    
    <!-- Dependencies -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands (Pinned Version) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff004c;
            --neon-green: #0aff00;
            --neon-yellow: #ffee00;
            --ui-bg: rgba(0, 10, 30, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        /* Layering: Video (Back) -> Canvas (Middle) -> UI (Front) */
        #input_video {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
            z-index: 1;
        }

        #output_canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through if needed, though we use gestures */
        }

        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--ui-bg);
            color: white;
            transition: opacity 0.3s;
            pointer-events: auto;
        }

        .hidden { display: none !important; }
        .faded { opacity: 0; pointer-events: none; }

        h1 { font-size: 3rem; text-shadow: 0 0 20px var(--neon-blue); margin-bottom: 10px; text-align: center; }
        h2 { font-size: 1.5rem; color: var(--neon-blue); margin-bottom: 20px; }
        p { max-width: 600px; line-height: 1.5; text-align: center; font-size: 1.1rem; }

        button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.5rem;
            background: transparent;
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--neon-blue);
            transition: 0.2s;
            font-family: inherit;
            font-weight: bold;
        }
        button:hover {
            background: var(--neon-blue);
            color: black;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            color: white;
            font-weight: bold;
        }

        #score-box { top: 20px; left: 20px; font-size: 1.5rem; }
        #wave-box { top: 20px; right: 20px; text-align: right; }
        
        #shield-container {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            border: 2px solid white;
            background: rgba(0,0,0,0.5);
        }
        #shield-bar {
            width: 100%; height: 100%;
            background: var(--neon-blue);
            transition: width 0.2s, background-color 0.2s;
        }

        #ult-container {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 10px;
            border: 1px solid var(--neon-yellow);
        }
        #ult-bar {
            width: 0%; height: 100%;
            background: var(--neon-yellow);
            box-shadow: 0 0 10px var(--neon-yellow);
            transition: width 0.1s;
        }
        #ult-text {
            position: absolute;
            bottom: 45px; left: 50%;
            transform: translateX(-50%);
            color: var(--neon-yellow);
            font-size: 0.8rem;
            letter-spacing: 2px;
            display: none;
        }

        #loading-overlay { z-index: 20; }
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: var(--neon-blue);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Floating Text */
        .float-text {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            pointer-events: none;
            text-shadow: 0 0 5px black;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }

        .guide-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            text-align: left;
            margin-bottom: 20px;
        }
        .gesture-item h3 { color: var(--neon-green); margin: 0; font-size: 1rem; }
        .gesture-item span { font-size: 0.9rem; color: #ccc; }
        
        #error-banner {
            position: absolute;
            bottom: 10px; left: 10px;
            background: var(--neon-red);
            color: white;
            padding: 5px 10px;
            font-size: 0.8rem;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <!-- Video Feed -->
    <video id="input_video" playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="output_canvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- Loading Screen -->
        <div id="loading-overlay" class="screen">
            <div class="spinner"></div>
            <h2 id="loading-text">Initializing Systems...</h2>
            <p id="loading-sub">Please allow camera access.</p>
            <button id="retry-btn" class="hidden" onclick="location.reload()">Retry</button>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="screen hidden">
            <h1>AR METEOR BLASTER</h1>
            <div class="guide-grid">
                <div class="gesture-item">
                    <h3>FINGER GUN</h3>
                    <span>Aim with Index. Tap Thumb to Shoot.</span>
                </div>
                <div class="gesture-item">
                    <h3>OVERCHARGE</h3>
                    <span>Hold Finger Gun steady for 1s.</span>
                </div>
                <div class="gesture-item">
                    <h3>ULTIMATE</h3>
                    <span>Cross arms on chest, then Open.</span>
                </div>
                <div class="gesture-item">
                    <h3>PAUSE</h3>
                    <span>Show Open Palm for 1s.</span>
                </div>
            </div>
            <button id="start-btn">ENGAGE DEFENSES</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden">
            <div id="score-box">SCORE: <span id="score-val">0</span></div>
            <div id="wave-box">TIME: <span id="time-val">00:00</span></div>
            
            <div id="shield-container">
                <div id="shield-bar"></div>
            </div>
            
            <div id="ult-text">NOVA BLAST READY</div>
            <div id="ult-container">
                <div id="ult-bar"></div>
            </div>
        </div>

        <!-- Pause Menu -->
        <div id="pause-menu" class="screen hidden" style="background: rgba(0,0,0,0.8);">
            <h2>SYSTEM PAUSED</h2>
            <button id="resume-btn">RESUME</button>
            <button onclick="location.reload()" style="margin-top: 10px; font-size: 1rem; border-color: var(--neon-red); color: var(--neon-red);">ABORT (RESTART)</button>
        </div>

        <!-- Game Over -->
        <div id="game-over" class="screen hidden">
            <h1 style="color: var(--neon-red);">CRITICAL FAILURE</h1>
            <p>The city has fallen.</p>
            <p>Final Score: <span id="final-score" style="color: var(--neon-blue); font-size: 1.5rem;">0</span></p>
            <p>Survival Time: <span id="final-time">0</span></p>
            <button onclick="location.reload()">REBOOT SYSTEM</button>
        </div>

        <!-- Floating Text Container -->
        <div id="floating-text-container"></div>
        <div id="error-banner"></div>
    </div>

<script>
/**
 * AR METEOR BLASTER
 * Single File Implementation
 */

// --- CONFIGURATION ---
const CONFIG = {
    cameraZ: 5,
    spawnRadius: 20,
    shieldMaxHP: 100,
    ultMax: 100,
    ultChargeRate: 0.5, // per frame
    laserSpeed: 40,
    maxMeteors: 20,
    colors: {
        laser: 0x00f3ff,
        laserCharged: 0xff004c,
        meteor: 0x888888,
        bomb: 0x330000,
        powerup: 0x0aff00
    }
};

// --- GLOBAL STATE ---
const state = {
    isLoading: true,
    isPlaying: false,
    isPaused: false,
    isGameOver: false,
    score: 0,
    shieldHP: CONFIG.shieldMaxHP,
    ultMeter: 0,
    startTime: 0,
    lastFrameTime: 0,
    gestures: {
        aim: { x: 0.5, y: 0.5 }, // 0-1 Normalized
        isFiring: false,
        isCharging: false,
        chargeTime: 0,
        isPalmOpen: false,
        palmOpenTime: 0,
        isCrossed: false
    },
    audioEnabled: true
};

// --- THREE.JS GLOBALS ---
let scene, camera, renderer;
let meteors = [];
let particles = [];
let lasers = [];
let crosshair;
let cityShieldMesh;

// --- AUDIO CONTEXT ---
let audioCtx;
const AudioSys = {
    init: () => {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        } catch(e) { console.warn("Audio init failed", e); }
    },
    playTone: (freq, type, duration, vol = 0.1) => {
        if (!state.audioEnabled || !audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    playLaser: (charged = false) => {
        if(charged) AudioSys.playTone(800, 'sawtooth', 0.4, 0.2);
        else AudioSys.playTone(1200, 'square', 0.1, 0.1);
    },
    playExplosion: () => {
        if (!state.audioEnabled || !audioCtx) return;
        // White noise approximation
        const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 sec
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        
        // Lowpass filter for "boom"
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    playShieldHit: () => {
        AudioSys.playTone(150, 'sine', 0.5, 0.3);
    },
    playPowerup: () => {
        if (!state.audioEnabled || !audioCtx) return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(now + 0.2);
    }
};

// --- INITIALIZATION ---
window.onload = function() {
    initThreeJS();
    initMediaPipe();
    setupUI();
};

function initThreeJS() {
    const canvas = document.getElementById('output_canvas');
    renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    scene = new THREE.Scene();
    
    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, CONFIG.cameraZ);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Crosshair
    const chGeo = new THREE.RingGeometry(0.1, 0.12, 32);
    const chMat = new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.8 });
    crosshair = new THREE.Mesh(chGeo, chMat);
    crosshair.position.set(0, 0, 1); // Close to camera
    scene.add(crosshair);

    // City Shield (Visual effect at center)
    const sGeo = new THREE.IcosahedronGeometry(1, 2);
    const sMat = new THREE.MeshBasicMaterial({ 
        color: 0x00f3ff, 
        wireframe: true, 
        transparent: true, 
        opacity: 0.0 
    });
    cityShieldMesh = new THREE.Mesh(sGeo, sMat);
    scene.add(cityShieldMesh);

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function initMediaPipe() {
    const videoElement = document.getElementById('input_video');

    function onHandsResults(results) {
        // Hide loading on first success
        if (state.isLoading && results.multiHandLandmarks) {
            state.isLoading = false;
            document.getElementById('loading-overlay').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
        }

        if (!state.isPlaying || state.isPaused) return;

        try {
            processGestures(results);
        } catch (e) {
            console.error("Gesture Error:", e);
            const errDiv = document.getElementById('error-banner');
            errDiv.style.display = "block";
            errDiv.innerText = "Tracking Error - Reset Hands";
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    cameraUtils.start().catch(e => {
        console.error("Camera failed", e);
        document.getElementById('loading-text').innerText = "Camera Access Denied";
        document.getElementById('loading-sub').innerText = "Check permissions and try again.";
        document.getElementById('retry-btn').classList.remove('hidden');
    });
}

// --- GESTURE LOGIC ---
function processGestures(results) {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

    // We focus on the first detected hand for aiming
    const landmarks = results.multiHandLandmarks[0];
    const handedness = results.multiHandedness[0].label; // "Left" or "Right"
    
    // 1. Aiming (Index Finger Tip) - Landmark 8
    // Coordinates are 0-1. 0,0 is top-left.
    // Mirror X because we mirrored the video CSS.
    const rawX = 1.0 - landmarks[8].x; 
    const rawY = landmarks[8].y;

    // Smooth aiming
    state.gestures.aim.x += (rawX - state.gestures.aim.x) * 0.2;
    state.gestures.aim.y += (rawY - state.gestures.aim.y) * 0.2;

    // 2. Finger Gun Detection
    // Check if Middle, Ring, Pinky tips are below their PIP joints (curled)
    const isMiddleCurled = landmarks[12].y > landmarks[10].y;
    const isRingCurled = landmarks[16].y > landmarks[14].y;
    const isPinkyCurled = landmarks[20].y > landmarks[18].y;
    const isIndexExtended = landmarks[8].y < landmarks[6].y;

    const isGunPose = isIndexExtended && isMiddleCurled && isRingCurled && isPinkyCurled;

    // 3. Trigger Action (Thumb)
    // Distance between Thumb Tip (4) and Index Base (5)
    const thumbIndexDist = distance(landmarks[4], landmarks[5]);
    const TRIGGER_THRESH = 0.06; // Tunable

    if (isGunPose) {
        // Charging logic
        if (thumbIndexDist > TRIGGER_THRESH) {
            // Thumb is UP (Hammer cocked)
            state.gestures.chargeTime += 0.016; // Approx 60fps
            if (state.gestures.chargeTime > 1.0) state.gestures.isCharging = true;
            state.gestures.isFiring = false; // Reset fire flag so we can fire again
        } else {
            // Thumb is DOWN (Hammer hit) - Shoot!
            if (!state.gestures.isFiring) {
                state.gestures.isFiring = true;
                fireLaser(state.gestures.isCharging);
                state.gestures.isCharging = false;
                state.gestures.chargeTime = 0;
            }
        }
    } else {
        state.gestures.isCharging = false;
        state.gestures.chargeTime = 0;
    }

    // 4. Pause Gesture (Open Palm)
    // All fingers extended
    const isPalm = !isMiddleCurled && !isRingCurled && !isPinkyCurled && isIndexExtended;
    if (isPalm) {
        state.gestures.palmOpenTime += 0.016;
        if (state.gestures.palmOpenTime > 1.0) {
            togglePause();
            state.gestures.palmOpenTime = 0; // Reset to prevent rapid toggling
        }
    } else {
        state.gestures.palmOpenTime = 0;
    }

    // 5. Ultimate (Cross Arms)
    // Need two hands
    if (results.multiHandLandmarks.length === 2) {
        const hand1 = results.multiHandLandmarks[0];
        const hand2 = results.multiHandLandmarks[1];
        
        // Check wrist positions (Landmark 0)
        // If x coords cross significantly
        const wrist1 = hand1[0];
        const wrist2 = hand2[0];
        
        const dist = Math.abs(wrist1.x - wrist2.x);
        
        // Simple cross check: if wrists are close and then move apart quickly?
        // Let's stick to "Current State": Are they crossed?
        // Assuming video is mirrored: Left hand on screen is Right hand in reality
        // Logic: Just check proximity of wrists in center screen
        const crossed = dist < 0.15;
        
        if (crossed && !state.gestures.isCrossed) {
             state.gestures.isCrossed = true;
             // Audio cue?
        } else if (!crossed && state.gestures.isCrossed) {
            // Uncrossed -> Trigger Ult
            if (state.ultMeter >= CONFIG.ultMax) {
                triggerUltimate();
            }
            state.gestures.isCrossed = false;
        }
    }
}

function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

// --- GAME LOGIC ---

function setupUI() {
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('resume-btn').addEventListener('click', togglePause);
}

function startGame() {
    AudioSys.init();
    state.isPlaying = true;
    state.isGameOver = false;
    state.score = 0;
    state.shieldHP = CONFIG.shieldMaxHP;
    state.ultMeter = 0;
    state.startTime = Date.now();
    
    // Clear objects
    meteors = [];
    lasers = [];
    particles = [];
    
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    document.getElementById('floating-text-container').innerHTML = '';

    updateHUD();
    gameLoop();
}

function togglePause() {
    state.isPaused = !state.isPaused;
    const menu = document.getElementById('pause-menu');
    if (state.isPaused) menu.classList.remove('hidden');
    else menu.classList.add('hidden');
}

function gameOver() {
    state.isPlaying = false;
    state.isGameOver = true;
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('game-over').classList.remove('hidden');
    document.getElementById('final-score').innerText = state.score;
    
    const elapsed = Math.floor((Date.now() - state.startTime)/1000);
    const m = Math.floor(elapsed / 60);
    const s = elapsed % 60;
    document.getElementById('final-time').innerText = `${m}:${s.toString().padStart(2,'0')}`;
}

// Spawning Logic
let spawnTimer = 0;
let difficultyMultiplier = 1;

function spawnMeteor() {
    if (meteors.length >= CONFIG.maxMeteors) return;

    const typeRoll = Math.random();
    let type = 'normal';
    let size = 1;
    let hp = 1;
    let color = CONFIG.colors.meteor;

    if (typeRoll > 0.95) { type = 'powerup'; color = CONFIG.colors.powerup; size=0.5; }
    else if (typeRoll > 0.85) { type = 'bomb'; color = CONFIG.colors.bomb; hp=3; size=1.5; }
    else if (typeRoll > 0.70) { type = 'large'; hp=3; size=2; }

    // Random pos on sphere
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = CONFIG.spawnRadius;
    
    // Keep away from direct back/front to ensure visibility
    // We restrict Z to be negative (in front of camera)
    const z = -Math.abs(r * Math.sin(phi) * Math.sin(theta));
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.cos(phi);

    const geometry = new THREE.DodecahedronGeometry(size, 0);
    const material = new THREE.MeshPhongMaterial({ 
        color: color, 
        flatShading: true,
        emissive: color,
        emissiveIntensity: 0.2
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, y, z);
    
    // Look at center
    mesh.lookAt(0,0,0);

    scene.add(mesh);

    meteors.push({
        mesh: mesh,
        type: type,
        hp: hp,
        velocity: new THREE.Vector3(-x, -y, -z).normalize().multiplyScalar(0.05 * difficultyMultiplier),
        isDead: false
    });
}

function fireLaser(isCharged) {
    AudioSys.playLaser(isCharged);

    // Get aiming vector from camera through aim point
    // Convert aim X/Y (0-1) to clip space (-1 to 1)
    const clipX = (state.gestures.aim.x * 2) - 1;
    const clipY = -(state.gestures.aim.y * 2) + 1; // Invert Y

    // Raycast logic
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(clipX, clipY), camera);

    // Visual Beam
    // We fire from slightly below camera (simulating hand position)
    const startPos = new THREE.Vector3(clipX * 5, clipY * 3 - 2, 2); 
    const endPos = new THREE.Vector3();
    
    // Determine target
    let target = null;
    let minDist = Infinity;

    // Check intersections with Meteors
    // Optimization: Raycaster against Mesh array
    const meshes = meteors.map(m => m.mesh);
    const intersects = raycaster.intersectObjects(meshes);

    if (intersects.length > 0) {
        target = intersects[0];
        endPos.copy(target.point);
        
        // Find the meteor object
        const hitMeteorIndex = meteors.findIndex(m => m.mesh === target.object);
        if (hitMeteorIndex !== -1) {
            handleHit(meteors[hitMeteorIndex], isCharged);
        }
    } else {
        // Miss - shoot into distance
        raycaster.ray.at(50, endPos);
    }

    // Create Laser Mesh
    const geo = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
    const mat = new THREE.LineBasicMaterial({ 
        color: isCharged ? CONFIG.colors.laserCharged : CONFIG.colors.laser,
        linewidth: 2 
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    
    lasers.push({ mesh: line, life: 10 }); // 10 frames of visibility
}

function handleHit(meteor, isCharged) {
    const damage = isCharged ? 5 : 1;
    meteor.hp -= damage;

    // Flash effect
    meteor.mesh.material.emissiveIntensity = 1.0;
    setTimeout(() => { if(meteor.mesh) meteor.mesh.material.emissiveIntensity = 0.2; }, 100);

    if (meteor.hp <= 0) {
        destroyMeteor(meteor, true); // true = by player
        
        // Explosion AOE if charged
        if (isCharged) {
            // Find nearby meteors
            meteors.forEach(other => {
                if (other !== meteor && other.mesh.position.distanceTo(meteor.mesh.position) < 5) {
                    other.hp -= 3;
                    if(other.hp <= 0) destroyMeteor(other, true);
                }
            });
        }
    }
}

function triggerUltimate() {
    AudioSys.playExplosion(); // Big boom
    showFloatingText("NOVA BLAST!", window.innerWidth/2, window.innerHeight/2, 'yellow');
    
    // Wipe all meteors
    [...meteors].forEach(m => {
        createExplosion(m.mesh.position, 20, CONFIG.colors.laser);
        destroyMeteor(m, true);
    });
    
    state.ultMeter = 0;
    updateHUD();
}

function destroyMeteor(meteor, byPlayer) {
    if (meteor.isDead) return;
    meteor.isDead = true;

    // Remove from scene happens in update loop
    createExplosion(meteor.mesh.position, meteor.type === 'bomb' ? 30 : 10, meteor.mesh.material.color.getHex());
    AudioSys.playExplosion();

    if (byPlayer) {
        if (meteor.type === 'bomb') {
            state.shieldHP -= 20;
            showFloatingText("BOMB HIT!", toScreenX(meteor.mesh.position), toScreenY(meteor.mesh.position), 'red');
            AudioSys.playShieldHit();
        } else if (meteor.type === 'powerup') {
            state.shieldHP = Math.min(state.shieldHP + 15, CONFIG.shieldMaxHP);
            state.ultMeter = Math.min(state.ultMeter + 20, CONFIG.ultMax);
            AudioSys.playPowerup();
            showFloatingText("POWER UP!", toScreenX(meteor.mesh.position), toScreenY(meteor.mesh.position), 'lime');
        } else {
            state.score += (meteor.type === 'large' ? 50 : 10);
            state.ultMeter = Math.min(state.ultMeter + 5, CONFIG.ultMax);
            showFloatingText("HIT", toScreenX(meteor.mesh.position), toScreenY(meteor.mesh.position));
        }
    } else {
        // Impact on city (reached center)
        if (meteor.type !== 'powerup') {
            state.shieldHP -= (meteor.type === 'large' ? 20 : 10);
            AudioSys.playShieldHit();
            
            // Visual feedback on shield
            cityShieldMesh.material.opacity = 0.8;
        }
    }
    updateHUD();
}

function createExplosion(pos, count, colorHex) {
    const geo = new THREE.TetrahedronGeometry(0.2);
    const mat = new THREE.MeshBasicMaterial({ color: colorHex });
    
    for(let i=0; i<count; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        // Random velocity
        const vel = new THREE.Vector3(
            Math.random()-0.5, Math.random()-0.5, Math.random()-0.5
        ).normalize().multiplyScalar(0.2 + Math.random()*0.3);
        
        scene.add(mesh);
        particles.push({ mesh: mesh, velocity: vel, life: 60 });
    }
}

// --- UPDATE LOOP ---
function gameLoop() {
    if (!state.isPlaying) return;
    requestAnimationFrame(gameLoop);
    
    if (state.isPaused) return;

    // 1. Update Meteors
    spawnTimer++;
    if (spawnTimer > (120 / difficultyMultiplier)) {
        spawnMeteor();
        spawnTimer = 0;
        difficultyMultiplier += 0.001; // Slowly get harder
    }

    for (let i = meteors.length - 1; i >= 0; i--) {
        const m = meteors[i];
        if (m.isDead) {
            scene.remove(m.mesh);
            meteors.splice(i, 1);
            continue;
        }

        m.mesh.position.add(m.velocity);
        m.mesh.rotation.x += 0.01;
        m.mesh.rotation.y += 0.01;

        // Check distance to center
        if (m.mesh.position.length() < 1.0) {
            destroyMeteor(m, false);
        }
    }

    // 2. Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life--;
        p.mesh.position.add(p.velocity);
        p.mesh.rotation.z += 0.1;
        if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }

    // 3. Update Lasers
    for (let i = lasers.length - 1; i >= 0; i--) {
        const l = lasers[i];
        l.life--;
        l.mesh.material.opacity = l.life / 10;
        if (l.life <= 0) {
            scene.remove(l.mesh);
            lasers.splice(i, 1);
        }
    }

    // 4. Update Shield Visual
    if (cityShieldMesh.material.opacity > 0) {
        cityShieldMesh.material.opacity -= 0.02;
    }

    // 5. Update Crosshair Position based on Gesture
    // Map aim (0-1) to camera view plane at z=1
    // Simplification: just move mesh, assuming fixed camera
    // Frustum width at Z=1 is approx aspect * tan(fov/2)*2
    // But easier: map aim 0-1 to X/Y relative to camera orientation.
    // Actually, let's use the mouse approach logic but inverted for camera
    // We already calculated clip space in Fire.
    // Update visual crosshair position:
    const vector = new THREE.Vector3((state.gestures.aim.x * 2 - 1), -(state.gestures.aim.y * 2 - 1), 0.5);
    vector.unproject(camera);
    const dir = vector.sub(camera.position).normalize();
    const distance = 4; // Distance from camera to place crosshair
    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
    crosshair.position.copy(pos);
    crosshair.lookAt(camera.position);

    // Crosshair Animation (Pulse if charging)
    if(state.gestures.isCharging) {
        const s = 1 + Math.sin(Date.now() * 0.02) * 0.2;
        crosshair.scale.set(s, s, s);
        crosshair.material.color.setHex(CONFIG.colors.laserCharged);
    } else {
        crosshair.scale.set(1,1,1);
        crosshair.material.color.setHex(CONFIG.colors.laser);
    }

    // 6. Game Over Check
    if (state.shieldHP <= 0) {
        gameOver();
    }

    // 7. Render
    renderer.render(scene, camera);
    
    // Update Timer UI
    const elapsed = Math.floor((Date.now() - state.startTime)/1000);
    const m = Math.floor(elapsed / 60);
    const s = elapsed % 60;
    document.getElementById('time-val').innerText = `${m}:${s.toString().padStart(2,'0')}`;
}

// --- UTILS ---

function updateHUD() {
    document.getElementById('score-val').innerText = state.score;
    document.getElementById('shield-bar').style.width = Math.max(0, state.shieldHP) + '%';
    
    const ultPct = (state.ultMeter / CONFIG.ultMax) * 100;
    document.getElementById('ult-bar').style.width = ultPct + '%';
    
    const ultText = document.getElementById('ult-text');
    if (ultPct >= 100) {
        ultText.style.display = 'block';
        ultText.style.animation = 'pulse 0.5s infinite alternate';
    } else {
        ultText.style.display = 'none';
    }
}

function showFloatingText(text, x, y, color = 'white') {
    const div = document.createElement('div');
    div.className = 'float-text';
    div.innerText = text;
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    div.style.color = color;
    document.getElementById('floating-text-container').appendChild(div);
    setTimeout(() => div.remove(), 1000);
}

function toScreenX(pos) {
    const v = pos.clone().project(camera);
    return (v.x + 1) / 2 * window.innerWidth;
}

function toScreenY(pos) {
    const v = pos.clone().project(camera);
    return -(v.y - 1) / 2 * window.innerHeight;
}

</script>
</body>
</html>